# -*- coding: utf-8 -*-
"""Estrutura de Dados Aula 02

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A_P7szfHnF9JV7L7bZRVqI0r57rcvSL0

#Estrutura de Dados Aula 02

**Bubble Sort: Algoritimo**

A lógica é comparar o número anterior com o próximo. Se precisar inverter para ordenar, a ação será feita.

Como há 5 elementos, 5 numeros na lista, essa verificação varrerá cada possição da lista 5 vezes para verificar se todas as posições esta com "false" na necessidade de troca, e com isso se dará a ordem com concluida.
"""

def bubbleSort(dados): #Dados tem que vir de uma lista apra ordenar
  tamanho = len(dados)
  for v in range(0,tamanho,1): # numero de vezes que laço varrerá a lista
    for i in range(0,tamanho-1,1):
      if dados[i] > dados[i+1]:
        trocando = dados[i] # salva temporariamente o numero que será trocado
        dados[i] = dados[i+1] # trocando o lugar
        dados[i+1] = trocando # Devolve ao novo local o número armazeando na variável temporária

#Main
dados = [5,4,2,1,8]
bubbleSort(dados)
print(dados)

#Complexidade Big-O: O(n**2)

"""**Merge Sort**

Dividindo os dados sempre ao meio (dividir para conquistar), até não poder dividir mais. Sempre posições inteiras.

Querando até a menor parte, juntando-os e ordenando-os, montado-os novamente.
"""

def margeSort(dados):
  if len(dados) > 1: #Verificação se rpecisa ou não continuar dividindo os dados
    # Divisão da lista (n)
    meio = len(dados)//2 #pegando apenas a parte inteira
    esquerda = dados[:meio] #meio pro final (0 a 5)
    direita = dados[meio:]# meio pro começo (4 a 9)
    margeSort(esquerda) #recursividade para dividir os dados, até o if da "false"
    margeSort(direita)  #recursividade para dividir os dados, depois de terminar o margeSort(esquerda), irá até o if da "false"
    # Mescla dos dados, agrupando os dados (logn)
    i = j = k = 0
    while i < len(esquerda) and j<len(direita):#copiando os dados para os locais corretos
      if esquerda[i]<direita[j]:
        dados[k]=esquerda[i]
        i+=1
      else:
        dados[k]=direita[j]
        j+=1
      k+=1
    while i<len(esquerda): #ajuda, caso algum dado esteja fora do loop do lado esquerdo
      dados[k] = esquerda[i]
      i+=1
      k+=1
    while j<len(direita): #ajuda, caso algum dado esteja fora do loop do lado esquerdo
      dados[k] = direita[j]
      j+=1
      k+=1

#Main
dados = [54,26,93,17,99,77,31,44,55]
margeSort(dados)
print(dados)

#Temos 3 niveis na árvore de divisão (0 a 3).
#total de conjutnos por nível é:
#0: 2**0 = 1
#1: 2**1 = 2
#2: 2**2 = 4
#3: 2**3 = 8

#total de chamadas recursivas da função com 3 níveis:
total=[[2**0],[2**1],[2**2],[2**3]]
soma= total[0]+total[1]+total[2]+total[3]
print(f'Total de chamadas recursivas é {sum(soma)}')

# Complexidade:
# O(logn).O(n) = OMargeSort(n.logn)

"""**Quick Sort**

Conhecido com ordenação rápida.

Contém o principio de "dividir para conquistar", porém com uma lógica diferente.

O Quick Sort só pode ser atualizado com três elemntos ou mais.

 o quick sort elege um dos dados como "pivô", geralamente o primeiro dado da lista, como referência, comparando com todos os dados a esquerda e todos os dados a direita do "pivô", se é ou não maiores que o pivô e jogando para esquerda ou não.

 Após esta divisão, organiza-se os lados e seus elementos entre si. Elementos da esquerda com eles mesmos e os da direita com eles mesmo, elegendo-os novos "pivôs", caso, cada lado tenha mais de três elementos para que se possa usar o quick sort.

 Caso fique apenas 2 elementos, é feito um ordenação simples com esses elementos.

"""

def quickSort(dados, inicio, fim): # tem recursão e dividir para conquistar (logn)
  if inicio < fim:
    posicaoDeParticionamento = particao(dados, inicio, fim) #organizaçaõ dos dados
    quickSort(dados, inicio, posicaoDeParticionamento - 1) # recursivamente, até o pivo
    quickSort(dados, posicaoDeParticionamento +1, fim) # recursivamente após o pivo.

def particao(dados, inicio, fim): #2 laços de repetição como PA = n*n = n**2
  pivo = dados[inicio]
  esquerda = inicio + 1
  direita = fim
  flag = False
  while not flag:
    while esquerda <= direita and dados[esquerda] <= pivo: #Varre ṕara esquerda
      esquerda = esquerda + 1 # marcação das posições onde parou
    while dados[direita] >= pivo and direita >= esquerda: #varre para direita
      direita = direita - 1 # marcação das posições onde parou
    if direita < esquerda:
      flag = True
    else:
      temporario = dados[esquerda]
      dados[esquerda] = dados[direita]
      dados[direita] = temporario
  temporario = dados[inicio]
  dados[inicio] = dados[direita]
  dados[direita]= temporario
  return direita

#Main
dados =[50,25,92,16,76,30,43,54,19]
quickSort(dados,0,len(dados)-1) # (n**2*logn) = (n**2), pq n**2 cresce bem amsi rapido do que logn e isso faz com que possamos negligênciar logn
print(dados)

# Complexidade Big-O:
# O f_quickSort(logn), O fparticao(n**2), Oquicksort(n**2.logn)=O(n**2)

"""**Buble sort e Quick Sort**, tem a mesma complexidade _O(n**2)_<br>
**Marge Sort**, tem a complexidade de _O(n.logn)_. E isso faz com que se saia melhor que os outros dois casos,em analise de piro caso. pois os outros dois se sae pior que o _Marge Sort_

#Minhas Ideias
"""

esquerda =[]
direita = []
def quickSort(dados): #definir quem vai para o lado esquerdo (menor que o "pivô") ou não
  pivo = dados[0]
  #print(pivo)
  for i in dados:
    if pivo > i:
      #print(i)
      paraEsquerda = i
      esquerda.append(paraEsquerda)
      quickSort(esquerda)
    else:
      #print("não tem")
      paraDireita = i
      direita.append(paraDireita)
      if len(direita) < 2:
        # if direira[0] > direita[1]:
        #   trocando = direita[0] # salva temporariamente o numero que será trocado
        #   direita[0] = direita[1] # trocando o lugar
        #   direita[1] = trocando # Devolve ao novo local o número armazeando na variável temporária
        trocando(direita)
      else:
        quickSort(direita)

def trocando(lista):
  if lista[0] > lista[1]:
      trocando = lista[0] # salva temporariamente o numero que será trocado
      lista[0] = lista[1] # trocando o lugar
      lista[1] = trocando # Devolve ao novo local o número armazeando na variável temporária
  return lista

# Main
lista=[25,9,8,3,8,9,10,15,80]
quickSort(lista)
print(lista)
print(esquerda)
print(direita)