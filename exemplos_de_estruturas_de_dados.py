# -*- coding: utf-8 -*-
"""Exemplos de Estruturas de Dados

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ShQAZ3rN4dMAvGF1gNMj6c0M1SFQxU3Y

**Notação Big-O**: Usada ara mostrar como a complexidade de tempore e de espaço cresce á medidad que a entrada também cresce. Para representar a compelxidade com o Big-O precisamos especificar somente a ordem de grandeza da função

Para ações **sequenciais** em um algoritimo, usamso **adição**.

Para ações **aninhadas** em um algoritimo, usamso **multiplicação**.

**OBS**: Exceto para _PG_, em que temo crescimento exponencial

**Recursivo**: Chama ela mesma. Exemplo, função recursiva, chama,dentro da função a pŕopria função.

#Fatorial Recursivo
"""

#Fatorial recursivo

def fatorial(n):
  fat = 1
  if n == 0 or n ==1:
    return fat
  else:
    return n * fatorial(n-1)

#Main
numero = int(input("\nDigite um nuemro para fatorar: "))
x = fatorial(numero)
print(x)

"""#Fibonacci Recursivo"""

#Fibonacci Recursivo

def fib(n):
  if n == 1 or n == 2:
    return 1
  else:
    return fib(n-1)+ fib(n-2)

#main
numero = int(input("\nDigite um nuemro para 'fibonar': "))
x = fib(numero)
print(x)

"""#Equação Geral de Recursividade

big-O ou O,

- O(uma chamada) * O(numero de chamadas ** numero de níveis)

**uma chamada**: Quadno não há laço ou outro tipod e complexidade, excluindo o return, ela será igual a 1.

**numero de chamadas**: è o número que ela foi chamada dentro da função. _exemplo_: na função _Fib()_, ela fi chamada duas vezes. Na função fatorial, foi chamda apeans uma vez.

**numero de níevis**: São so valores de _N_ passados em cada uma das funções.
"""

def equaGeral(nCamadas, nNiveis):
  if nNiveis == 1:
    return 1
  else:
    return nCamadas**nNiveis

#main
camadas = int(input("\nDigite o numero de camada(as): "))
niveis = int(input("\nDigite o numero de niveis: "))
x = equaGeral(camadas, niveis)
print(x)

"""#Resumo

- Algoritmo sem iteração nem recursão: O(1)
- Laço iterativo simples: O(n)
- Progressão Aritmética (PA): O(n)
- Progressão Geometrica (PG): O(2**n)
- Dividir para conquistar: O(log(n))
- Recursão Simples: O(n)
- Recursão em árvore binária: O(2**n)

**Progressão Aritmética (PA)**: Valores de progressões constantes. _Exemplo:_(4,7,10,13,16,..), onde a PA = 3 ou (70,60,50,40,30,20,10) onde a PA = -10

**Progressão Geometrica (PG)**: Valores das progressões não são constantes. _exemplo:_(1, 3, 9, 27, 81, …)

"""

#Exemplos

#1, big-O = O(n)

def exemplo01(dados):
  for i in range(0,len(dados)/2,1):
    dados[i]= i * 2

#2, big-O = O(n)

def exemplo02(dados):
  for i in range(0,len(dados),1):
    dados[i]= i * 1
  for i in range(0,len(dados),1):
    dados[i]= i - 1

#3, tem aninhamento,com PA constante, big-O = O(n**2)
def exemplo03(dados):
  for i in range(0,len(dados),1):
    for j in range(0,len(dados),1):
      dados[i]= dados[j] + 1

#4, tem aninhamento,com PA Não constante de -1, big-O = O(n**2)
def exemplo04(dados):
  for i in range(0,len(dados),1):
    for j in range(i,len(dados),1):
      dados[i]= dados[j] + 1

#5, tem aninhamento,big-O = O(n**2)
def exemplo05(dados):
  for i in range(0,len(dados),1):
    for j in range(i,len(dados),1):
      for k in range(i,9000000,1): #tamanho constante
        dados[i]= dados[j] + 1

#6, o laço não é PG porque não tem um laço interno apra executar geometricamente, big-O = O(raiz de-n)

def exemplo06(dados):
  for i in range(1,dados*dados,1): #i**2, i ao quadrado
    print(i, end="-")


#7, recursiva, com dividir para consquitar, onde dividir para conquistar tem prioridade sobre recursividade, big-O = O(logn)
def exemplo07(dados):
  n = dados
  if n==0:
    return
  exemplo07(n/2) #recursiva, pegando o conjunto de dados e dividindo ao meio.
  print(n)


#8, T sort(B) = O(B*logB) e T busca(B) = O (logB). Temo dependen^ncia de 2 conjuntos de dados
#t(A,B) = O(B*logB) + A*O(logB) = O((A+B).logB)
def exemplo08(dadosA=[], dadosB=[]):
  sort(dadosB)
  for i in range(0,len(dadosA),1):
    if(busca(dadosB,i)>= 0)
      return i

"""#Trabalhando com Algoritmo de Busca"""

import random

def buscaBinaria(inicio,fim, dados,buscando): #dividindo os dados ao meio (dividir para conquistar)
  while inicio <= fim:
    meio = int((inicio + fim)/2)
    if buscando > dados[meio]:
      inicio = meio+1 # corta a lista de numero começando do meio + 1, pegando do meio para o final da lista
    elif buscando < dados[meio]:
       fim = meio-1 # corta a lista de numero começando do meio - 1, pegando do meio para o incio da lista
    else:
      return meio
  return 'x'


#gerando 10 valores dentro de um intervalo de 0 até 9

dados = random.sample(range(10),10) #(10)- qauntidade de numeros, 10 - limitanto entre 0 a 9
dados.sort() # ordenando os valroes gerados
print(dados, end=" -> ")
buscando = int(input("Digite o valor desejado: "))
achou = buscaBinaria(0,len(dados), dados, buscando)
if achou == 'x': # Não achei como entrar aqui
  print("Valor não encontrado.")
else:
  print(f"Valor encontra na posição {achou}")